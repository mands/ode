-----------------------------------------------------------------------------
--
-- Module      :  Subsystem.Simulation.JITCompiler
-- Copyright   :  Copyright (C) 2010-2012 Mandeep Gill
-- License     :  GPL (Just (Version {versionBranch = [3], versionTags = []}))
--
-- Maintainer  :  mangil@comlab.ox.ac.uk
-- Stability   :  alpha
-- Portability :
--
-- | Takes a CoreFlat AST and simulates is using an JIT Compiler with a Forward Euler
-- This module includes the hihg-level functions generated by the JIT compiler and related
-- machinary for setting up and running a simulation
-----------------------------------------------------------------------------

{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, UndecidableInstances #-}

module Subsystem.Simulation.JITCompiler (
compile
) where

-- Labels
import Control.Category
import qualified Data.Label as L
import Prelude hiding ((.), id)

-- LLVM code
import LLVM.Wrapper.Core as LLVM
import LLVM.Wrapper.BitWriter as LLVM
import LLVM.Wrapper.ExecutionEngine as LLVM
import qualified LLVM.FFI.Core as LFFI
import qualified LLVM.Target.Native as LFFI

import Data.Int
import Data.Word
import qualified Foreign as FFI
import qualified Foreign.C as FFI

import qualified Data.Foldable as DF
import qualified Data.Traversable as DT
import qualified Data.Map as Map
import qualified Utils.OrdMap as OrdMap

import qualified Shelly as Sh

import Control.Monad.State
import Utils.MonadSupply

import Utils.CommonImports
import qualified Subsystem.SysState as Sys

import AST.Common as AC
import AST.CoreFlat as CF

import Subsystem.Simulation.JITCompiler.JITCommon
import Subsystem.Simulation.JITCompiler.JITSolver
import Subsystem.Simulation.JITCompiler.JITShell


-- Entry ---------------------------------------------------------------------------------------------------------------

compile :: CF.Module -> Sys.SysExceptIO ()
compile mod = do

    -- setup the default simulation state
    p <- Sys.getSysState Sys.lSimParams
    liftIO $ debugM "ode3.sim" $ "JIT Compiling Model"


    -- configure LLVM
    -- liftIO $ initializeNativeTarget
    lift $ runStateT (runGenM codeGen) $ mkGenState p


    liftIO $ debugM "ode3.sim" $ "Starting JIT Simulation"
    -- run the simulation
    -- liftIO $ runDynSimulation
    liftIO $ runStaticSimulation

    -- close any output files? (handle within LLVM code)
    liftIO $ debugM "ode3.sim" $ "JIT Simulation Complete"
    return ()
  where
    -- all code that runs in the SimM monad
    codeGen :: GenM ()
    codeGen = do
        createModule mod
        linkModule

-- JIT Interface -------------------------------------------------------------------------------------------------------
-- | Load our compiled module and run a simulation
-- TODO - need to handle dynamic/static linking and JIT/AOT compilation

createModule :: CF.Module -> GenM ()
createModule odeMod = do
    -- create the module
    llvmMod <- liftIO $ moduleCreateWithName "model"
    -- insert the math ops and lib ops
    (mathOps, libOps) <- liftIO $ defineExtOps llvmMod
    modify (\st -> st { llvmMod, mathOps, libOps })

    -- generate & insert the funcs into the module
    initsF <-   genModelInitials odeMod
    loopF <-    genModelLoop odeMod
    simF <-     genModelSolver odeMod initsF loopF

    -- save the module to disk
    liftIO $ printModuleToFile llvmMod "model.ll"
    liftIO $ writeBitcodeToFile llvmMod "model.bc"
    return ()

-- | Calls out to our link script
linkModule :: GenM ()
linkModule = do
    Sh.shelly . Sh.verbosely $ linkScript
    return ()



runDynSimulation :: IO ()
runDynSimulation = do
    -- load the linked/optimised module
    simMod <- readBitcodeFromFile "./sim.bc"

    -- setup the jitter
    LFFI.initializeNativeTarget
    ee <- createJITCompilerForModule simMod (fromIntegral 3)

    -- get and call the entry func
    modelSolverFunc <- fromJust <$> findFunction ee "modelSolver"
    _ <- runFunction ee modelSolverFunc (fromIntegral 0) []

    -- destroy Module
    disposeModule simMod
    return ()


-- | Calls out to our runStatic script
runStaticSimulation :: IO ()
runStaticSimulation = do
    Sh.shelly . Sh.verbosely $ runStaticScript
    return ()
