#!/usr/bin/env python3

"""
    High-level quick script to convert an initial C file code-generated by CellML/OpenCell into an Ode od3 file
    -- require much manual clean-up afterwards
"""
from datetime import timedelta
import os
import shutil
import logging
import argparse
import sys
import re
from functools import partial
from Common import *

cur_vals = set()
free_val_count = 0


def unique_dict(vals):
    """Create a dict from a list of tuples, ensureing all values are unique"""

    def unique_val(v):
        global free_val_count, cur_vals
        if v in cur_vals:
            free_val_count += 1
            new_v = "{}_new{}".format(v, free_val_count)
            logging.debug("Found a duplicate value - {} renamed as {}".format(v, new_v))
            return new_v
        else:
            cur_vals.add(v)
            return v

    return {k: unique_val(v) for k, v in vals}


def convert_file(in_filename, out_filename):
    logging.debug("Converting CellML file {} to Ode file {}".format(in_filename, out_filename))

    out_str = ""
    # read the file into a string
    with open(in_filename, 'r') as in_f:
        out_str = in_f.read()

    # scan the input files for the mappings
    constants_maps = unique_dict(re.compile('^ \* CONSTANTS\[(\d+)\] is (\w+) ', re.MULTILINE).findall(out_str))
    algebraic_maps = unique_dict(re.compile('^ \* ALGEBRAIC\[(\d+)\] is (\w+) ', re.MULTILINE).findall(out_str))
    states_maps = unique_dict(re.compile('^ \* STATES\[(\d+)\] is (\w+) ', re.MULTILINE).findall(out_str))
    rates_maps = {k: '_odedelta_' + v for k, v in states_maps.items()}  # rates is same as states array
    logging.debug("CONSTANTS maps - {}".format(constants_maps))
    logging.debug("ALGEBRAIC maps - {}".format(algebraic_maps))
    logging.debug("STATES maps - {}".format(states_maps))
    logging.debug("RATES maps - {}".format(rates_maps))

    # perform some global replaces - more to come - can't be related to var refs
    out_str = re.compile('VOI').sub('time', out_str)  # replace VOI with time
    out_str = re.compile('&&').sub(' and ', out_str)  # replace ands
    out_str = re.compile('\|\|').sub(' or ', out_str)  # replace ors
    out_str = re.compile(';$', re.MULTILINE).sub('', out_str)  # remove EOL ;'s
    out_str = re.compile('fabs\(').sub('abs(', out_str)  # replace fabs() with abs()

    # first the assignments
    # replace basic assignments
    def replace_assignment(val_type, name_map, match):
        return "  {} {} = ".format(val_type, name_map[match.group(1)])
    out_str = re.compile('^  CONSTANTS\[(\d+)\] = ', re.MULTILINE).sub(partial(replace_assignment, 'val', constants_maps), out_str)
    out_str = re.compile('^  ALGEBRAIC\[(\d+)\] = ', re.MULTILINE).sub(partial(replace_assignment, 'val', algebraic_maps), out_str)
    out_str = re.compile('^  STATES\[(\d+)\] = ', re.MULTILINE).sub(partial(replace_assignment, 'init', states_maps), out_str)

    # replace delta/rates
    def replace_rates(match):
        return "  ode {{ initVal : {}, deltaVal : {} }} = ".format(states_maps[match.group(1)], rates_maps[match.group(1)])
    out_str = re.compile('^  RATES\[(\d+)\] = ', re.MULTILINE).sub(replace_rates, out_str)

    # finally replace all references
    def replace_reference(name_map, match):
        return name_map[match.group(1)]
    out_str = re.compile('CONSTANTS\[(\d+)\]').sub(partial(replace_reference, constants_maps), out_str)
    out_str = re.compile('ALGEBRAIC\[(\d+)\]').sub(partial(replace_reference, algebraic_maps), out_str)
    out_str = re.compile('STATES\[(\d+)\]').sub(partial(replace_reference, states_maps), out_str)
    out_str = re.compile('RATES\[(\d+)\]').sub(partial(replace_reference, rates_maps), out_str)

    # pick up the piecewise
    def replace_piecewise(match):
        logging.debug("Piecewise match - {}".format(match.group(0)))
        cond_exp, true_exp, false_exp = match.group(1), match.group(2), match.group(3)
        return "= piecewise{{ {} : {}, default : {} }}".format(cond_exp, true_exp, false_exp)
    out_str = re.compile('= \(([^\?\n]+)\?([^:]+):(.+)\)$', re.MULTILINE).sub(replace_piecewise, out_str)

    # update fp nums if needed
    def replace_fp(match):
        logging.debug("FP match - {}".format(match.group(0)))
        return "{}.0{}".format(match.group(1), match.group(2))
    out_str = re.compile('(\d+)\.(\D)').sub(replace_fp, out_str)

    # more global replaces
    out_str = re.compile('gamma(\W)').sub(lambda match: "gamma_new{}".format(match.group(1)), out_str)  # rename gamma var

    # update the comments
    out_str = re.compile('^ \* (\w+) is (\w+) ', re.MULTILINE).sub(lambda match: " * {} is ".format(match.group(1)), out_str)

    # save the output string
    with open(out_filename, 'w') as out_f:
        out_f.write(out_str)


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)

    parser = argparse.ArgumentParser(
        description='ConvertCellML takes a C code-genned CellML file and produces a (non-working) Ode representation',  # main description for help
        epilog='Tested on Linux only'  # displayed after help
    )
    parser.add_argument("file", help="File to convert")
    parser.add_argument("-o", "--out-file", type=str, help="Output file")
    parser.add_argument("-f", "--force", action="store_true", default=False, help="Overwrite output file if exists")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose mode")
    args = parser.parse_args()

    in_file = os.path.abspath(args.file)
    if os.path.splitext(in_file)[1] != '.c':
        raise Exception("Input file is not a C file")

    out_file = os.path.abspath(args.out_file) if args.out_file else os.path.splitext(in_file)[0] + '.od3'

    if os.path.isfile(out_file) and not args.force:
        raise Exception("File already exists, rerun with --force flag")

    convert_file(in_file, out_file)
    logging.debug("Done")
