module A {
// PASS - test basic top lets
	val X1 = 3
	val Y1 = 3 + 3
	val Z1 = 3 > 0 and Y1 > X1


// PASS - test component - Float -> Float
    component inc(x) {
        return (x + 1)
    }
    val X2 = inc(3)
    val Y2 = X2 + X2
    val Z2 = Y2 + X2 + 23 
    val W2 = inc(5) + 2
    // what the fuck!
    // val Z2 = Y2 + X2 + Z2

// PASS - test component-local lets
    component let(x) {
	    val y = x + 1
		return (x+y)
	}
	
// more complicated components
// PASS - test (Float, Float) -> Float
    component add(x, y) {
        return (x + y)
    }
    val X3 = add(3, 4)
	
// PASS - test (Float, Float) -> (Float, Float)
    component addsub(x, y) {
        return (x + y, x - y)
    }
    val X4,Y4 = addsub(3, 4)
	// val Y,Z = X

// PASS - nested expressions
    component add(x, y) {
        return (x + y)
    }
    component dec(x) {
        return (x -1)
    }
    val Y5 = 2
    val X5 = add(3, dec(Y5))

// boolean tests
    component gt(x, y) {
        return (x > y)
    }
    component lt(x, y) {
        return (x < y)
    }
    component comAnd(x, y) {
        return (x and y)
    }
    component comOr(x, y) {
        return (x or y)
    }
    val X6 = comAnd(gt(2, 1), lt(2, 1))
    val X7 = comOr(gt(2, 1), lt(2, 1))

// PASS - component-local type error
/*
    component let2(x) {
	    val y = x + 1
		val z = x and y
		return (y, z)
	}
*/

// PASS - polymorphism test for lit module, should fail as cannot unify without uses
/*
    component id(x) {
		return (x)
	}
*/

// PASS - polymorphism test for lit module, should pass
    component id(x) {
		return (x)
	}
	val X7 = id(1) + 1

// PASS - comopnent artity errors
//    val X8 = inc(1,2)
//    val Y8 = add(1)

// PASS - call a val, add a component
//    val X9 = X1(1,2)
//    val Y9 = add + 2

}
