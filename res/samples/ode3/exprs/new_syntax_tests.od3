// basic tests for the new syntax

// new comp syntax
/*
module A {

  val valTest = 1

  component compTest (a,b) => (d,e) where {
    val d = a + 1
    val e = b + 1
  }
}
*/

// time term
/*
module B {
  val valTest = 1 + time
}
*/

// Unit term
/*
module C {
  val valTest = ()
  component compTest (unused) => (()) where {
    val a = 0
//    val b = unused
  }
  val start = compTest(valTest)
}
*/

// dont care vals
/*
module D {
  val _ = 1
  component compTest (a) => (()) where {
    val _ = 1 + a
  }
  val _ = compTest(1)
}
*/

// dont care components
/*
module E {
  component compTestA (_) => (1,2) where {
  }
  component compTestB (_, a) => (()) where {
    val _ = a + 1
  }
  val _ = compTestB(compTestA(()))
}
*/

// basic tuples exprs
/*
module E {
  val c = (1+1)
  val a,b = (1, 2)
}
*/


// tuples type system - toplevel
/*
module F {
    // val a,b = True

    val c,d = (1,2)
    
    val e = (1,2)
    val f,g = e

    val h = compTestA(1) // OK
    val i,j = compTestA(1) // OK

  component compTestA (a) => (1, 2) where {
    val b = 1+a
  }
}
*/

// tupes type system - let-exprs

module G {
  component compTestB (a) => (1, 2) where {
    // val b,c = 1 + a
    val b = 1+a
    val c,d = (1,2)   
    val e = (1,2)
    val f,g = e
  }
}


// validation errors
module H {
  val a = 1
  val a = 2
}

