// Functor Arg
module A {
  val x = 2
}

/*
// ref of a ref
module A1 = A
module A2 = A1
*/

// Functor
module B(A) {
    // import A  // use current file for scope
    // import ModTests.Imports.A  
    val y = 2 + A.x
}

// Functor Applications
// basic app
// module C = B(A)

// app using a ref'd-arg
// module D = A
// module E = B(D)

// app using a ref'd-functor
//module F = B
//module G = F(A)
//// and ref again
//module H = G


// app using a ref'd-functor & ref'd-arg
//module H = A
//module I = B
//module J = I(H)

// checking types still correct after wrapping within a RefMod
module K = A
module L = B
module M = K(K)
//module N = L(L)
//module O = K(L)


// app using the result

// nested app


